\chapter{Fejlesztői dokumentáció}
\begin{comment}
A Fejlesztői dokumentáció tartalmazza
- a probléma részletes specifikációját,
- a felhasznált módszerek részletes leírását, a használt fogalmak definícióját,
- a program logikai és fizikai szerkezetének leírását (adatszerkezetek, adatbázisok,
modulfelbontás),
- a tesztelési tervet és a tesztelés eredményeit.
\end{comment}

%% ----------------------------------------------{Megoldási terv}
\section{Megoldási terv}
A program működésileg 2 részre bontható: weboldalra(kliens) és a szerverre.
A weboldalon össze állított adatokat küldjük fel a szerverre, a szerver a megkapott adatok alapján számol. \newline
\subsection{Weboldal}
	A kliens megvalósításához az alábbi technológiák merültek fel : C++/Qt, C\#, JS/HTML. Végül JavaScript-ben lett megvalósítva, első sorban a grafikon kirajzoló (Flot) miatt, de a szerver kommunikáció egyszerűsége is döntő ok volt amellett, hogy egy weboldal bármely gépen egyszerűen megnyitható, kezelhető.\newline
	Egy oldalból áll melyen a felhasználó szerkesztheti az adatokat. Azért nem lettek a részek külön oldalakon megvalósítva, mert az egyik oldalról az adatok átvitele egy másik oldalra nem annyira egyszerű, viszont nincs is olyan komplex az oldal, hogy szükséges legyen több aloldalra szétbontani. 
	Az oldal megjelenés felépítése megtekinthető \ref{fig:weblap_vazlat}-es képen.
	\begin{figure}[h]
	\includegraphics[width=14cm]{pics/weblap_vazlat}
	\centering
	\caption{Weboldal vázlata\label{fig:weblap_vazlat}}
	\end{figure}
	A weboldalon meg kell valósítani a pontok dinamikus kirajzolását, és a táblázatos formában történő megjelenítést és szerkeszthetőséget. Mivel több interpolációt küldünk fel a szervernek ezért a weboldalon több szerkesztésére is lehetőséget kell adni. \newline 
	Több szerkesztésének megvalósításához kell egy menü rendszer, amelyben eltárolódnak az adatok, és képesek betöltődni.\newline
	Az oldalon input-okat használunk még, és a dinamikus táblázat is JavaScript-ből van legenerálva. A táblázatokban sorok beszúrására teljes táblázat törlésre is lehetőséget kell adni. 
	A táblázatokban inputok vannak az egyes cellákban melyben egyszerű értékek, vagy akár komplexebb Objektumok is találhatóak. A bonyolultabb objektumokat json string-ben tároljuk ezekben az inputokban. \newline
	A menü listájában új adathalmazokat hozhat létre, a régieket szerkesztheti.
	Amikor a felhasználó pontokat, megjelenítést frissít a legtöbb esetben az oldal már a háttérben menti az adatokat a listába. Amikor egy másik interpolációt választunk ki, akkor az betöltődik a táblázatba, és a grafikonba. A módosításoknál az értékei az ő oszlopában fognak törlődni.
	Ha a felhasználó végzett egy gombra nyomással a program legenerálja a szükséges objektumot. \newline
	A felület sok gombot tartalmaz, melyek hatására frissíthetőek az adatok. Amikor frissítünk egy részt, általában mentődnek az értékek egy inputba JSON formában.\newline
  	\subsubsection{Grafikon kirajzoló - Flot}

	\begin{figure}[h]
	\includegraphics[width=13cm]{pics/plot}
	\centering
	\caption{Grafikon kirajzoló\label{fig:plot}}

	\end{figure}
		A Grafikon megjelenítéséhez a Flot-ot használom. Ez egy jQuery-s könyvtár, melyben egyszerűen és látványosan lehet grafikonokat kirajzolni. A forrás a "WebPage/source/flot-8.0.2" mappában érhető el.
		HTML fájlban egy egyszerű "DIV"-ként jelenik meg, melyet aztán a JavaScript tölt meg tartalommal.
				\begin{minted}{html}
	<div id=\"resultplot\" class=\"demo-placeholder\"></div>
			\end{minted}
		A JavaScript-ben hivatkozhatunk erre a "DIV"-re, majd az adatok és a típusok segítségével alábbi módon hivatkozhatjuk meg: 
		\begin{minted}{javascript}
	    var placeholder = $("#resultplot");
	    var plot = $.plot(placeholder, flot_data, type);
		\end{minted}
		A paraméterezése a grafikon kirajzolónak az alábbi: 
		\begin{description}
			\item[placeholder] \hfill \\ 
	 			DIV hivatkozása
	 		 \item[type] \hfill \\ 
	 			Megjelenítendő grafikon típusa
	 			\newline
	 			A Flot sok lehetőséget nyújt a típusok kiválasztására, és ezekre való példákból megalkottam a saját típusomat mely a következőket tartalmazza egy objektumban:
		 		
		 		\begin{verbatim}
		 			series: { line: { show: true } } 
		 		\end{verbatim}
				Beállítjuk hogy a vonalakat jelenítse meg. Ekkor a pontokat is megjeleníti, a többi beállítás függvényében.
		 		
		 		\begin{verbatim}
					xaxis: { zoomRange: [0.1, 1], panRange: [-1000, 1000] }
					yaxis: { zoomRange: [0.1, 100], panRange: [-1000, 1000] }
		 		\end{verbatim} 
		 		X és Y koordinátákon nagyítás és mozgatási beállítások interaktívvá állítása
			 	\begin{verbatim}
			 		grid: { hoverable: true, clickable: true }
			 	\end{verbatim} 
			 	Ezeket a tulajdonságokat használjuk arra hogy felvegyünk új pontokat.\newline
			 	Emellett ha ráviszem az egeret az egyik pontra, megmutatja a pont koordinátáját, és értékeit, és hogy melyik ponthalmazon van.
			 	\begin{verbatim}
			 		zoom: { interactive: true}, pan: { interactive: true }
			 	\end{verbatim} 
			 	Nagyítás és kattintással mozgatás engedélyezése. \newline
				Ennek a beépítésével is foglalkoztam, de a kattintás sajnos nem egyeztethető könnyen össze a pont figyeléssel, valamint a beépítés után lassú lett, és akadozott a felület, így végül az interaktivitását külső komponensekkel(inputokkal) oldottam meg.

	 		\item[flot\_data] \hfill \\ 
	 		A tényleges adathalmazokat tartalmazó tömb, melyben az egyes adatokról egyéni információkat is tartalmazza.\newline
	 		\begin{description}
				\item[data] \hfill \\ 
				Pontok halmaza, melyeket megjelenítünk\newline
				[x, y] pontokból álló tömb\newline
				Polinom esetén is ezt használjuk, ezért a polinom behelyettesített értékeit adjuk itt meg. Amikor az egérrel felé megyünk ezeket a pontokat fogja megjeleníteni.
				\item[label] \hfill \\ 
				Adathalmaz elnevezése, ezt láthatjuk amikor az egérrel a pont felé visszük az egeret, valamint a színek-elnevezések össze párosításánál is segít.
				\item[points] \hfill \\ 
				Ha pontokat kívánunk megjeleníteni, akkor ezt a kapcsolót kell alkalmazni.
				\item[lines] \hfill \\ 
				Ha a pontokból alkotott vonalat kívánunk látni, akkor ezt a kapcsolót kell alkalmazni. Ezt használjuk a polinom megjelenítéséhez.
			\end{description}
	 		\begin{minted}{javascript}
		var example_datas = [{
			data: d4,
			label: "neved4",
			lines: { show: true }
		}, {
		    data: d3,
			label: "neved43"
		    points: { show: true }
		}];
			\end{minted}
		\end{description}

\subsection{Elosztott rendszer}
	Az elosztott rendszer megvalósításához az alábbi technológiák merültek fel: C++/PVM, Erlang.
	Miután a JavaScript mellett döntöttem a grafikus felületen, ezután optimálisabbnak tűnt egy hasonlóan gyengén típusos nyelvnek a használata. Az Erlang elég jól támogatja párhuzamosítást és a szerver kommunikációt is, és bár az algoritmusok implementálása nehézkesebb lett volna, de C++-ban megvalósított függvények beépítése miatt ez a probléma megoldódott.

	\subsubsection{Http szerver}
	A http szerver gyakolratilag 2 példából lett megvalósítva:
	"httpServer leírása TODO"
	\subsubsection{Node figyelő}
	"pingPong TODO: pidWatcher mit csinál"
	\subsubsection{Struktúra kezelő}
	"structHandler"
	\subsubsection{Elosztás}
	"nodeHandler"

\subsection{Számítás}
	A számítás megvalósításánál felmerült hogy Erlang-ban legyen, de mivel a számítást ciklusokkal érdemes megvalósítani, ezért egyszerűbb volt egy nem funkcionális nyelvben implementálni azokat.
	A C++-os függvényeket fel lehetett használni az Erlang modulokban.
	\newline
	\subsubsection{Erlang modul C++-ban}
	"erl\_nif"
\subsection{Kommunikáció}
	Amikor a szervert létrehozzuk akkor inicializálunk két processzt. Az egyik a kliens felől várakozik kérésre, a másik a node-ok felől. Amikor egy node fel kíván csatlakozni küld egy kérést. Ha sikeres volt akkor a szerver ezt jelzi neki, és felkerül a listára. \newline
	A weboldalon egy gomb hatására megy egy kérés a szerver felé. A szerver jó esetben fogadja a kérést. Ha nem sikerült kapcsolatba lépnie a szerverrel, akkor jelzi a felhasználónak hogy a kapcsolódás során hiba lépett fel. \newline
	Ha fogadta a kérést, akkor megpróbálja feldolgozni az adatokat. Ha sikeresen feldolgozta az adatokat, abban az esetben elindul a szétosztás. \newline
	A szétosztás során a felcsatlakozott gépeken létre jönnek a processzek, majd kapnak egy adathalmazt mellyel számolniuk kell. Ha végeztek, az eredményt vissza küldik a szülő processznek. A szülő processz, ha megkapott minden értéket, azt vissza küldi a weboldalnak.
	\newline
	A weboldal sikeres válasz után betölti az eredményeket. 
	\begin{figure}[h]
		\includegraphics[width=13cm]{pics/kommunikacio1}
	\centering
	\caption{Kommunikáció\label{fig:kommunikacio1}}
	\end{figure}

\section{Megvalósított fájlszerkezet}
	A fájlszerkezetnek a tervezésénél nem voltak a belső részek komolyabban megtervezve, dinamikusan változtak. 3 mappa volt a tervezett: elosztott rendszer és weboldal mappája. A többi mappa mind a külsők, és a belsők a fejlesztés során lettek bele tervezve, amikor a fájlok mennyisége, vagy az új technológia szeparálása megkívánta azt. 
	TODO: külső mappákról írás melyikben mi van megvalósítva
	Belső mappákról csak az általános "/source"-t említem meg, mert egyébként a belső mappaszerkezetet a részeknél lesz külön kifejtve

%% ----------------------------------------------{Weboldal}
\section{Weboldal megvalósítása}
\subsection{Felépítés}
	A weboldal forráskódja a /webpage mappában helyezkedik el. 
	A fájlszerkezet az alábbi:
	\begin{description}
		\item[webpage.js :] \hfill \\  
		Globális változók inicializálása és pár alapbeállítás lefuttatása
		
		\item[webpage.html :]  \hfill \\ 
		Weboldal megjelenítése, fájlok betöltése
		
		\item[init] \hfill \\ 
		Inicializáló függvények hívásai és események
		\begin{description}
			\item[menulist.js : ] \hfill \\ 
				Interpolációk listájának inicializálója
		  	\item[plot.js : ] \hfill \\ 
		  		Interpolációs grafikon inicializálása
			\item[table.js : ] \hfill \\ 
				Interpolációs táblázat inicializálása
		 	\item[events.js : ] \hfill \\ 
		 		Gombra kattintások eseményei
		\end{description}

		\item[model] \hfill \\ 
		Objektumok, melyeket az inicializáló lépésben hívunk, és azok segédletei
		\begin{description}
		 	\item[base.js : ] \hfill \\
		 		Globális függvények \newline
		 		Base.get, Base.erlangJSON, Base.forEach
		 	\item[base\_table.js : ] \hfill \\
		 		Általános táblázat generáló függvény
		 	\item[connection.js : ] \hfill \\
		 		Szerver kapcsolat meghívására szolgáló függvény \newline
		 		Connection.request
		 	\item[plot\_types.js : ] \hfill \\
		 		A grafikon kirajzoló típus objektumai
		 	\item[polinome.js : ] \hfill \\  
		 		Polinom kirajzolását segítő függvények \newline
		 		makePolinome található benne és egyéb segédfüggvények
		 	\item[web\_page\_debug.js : ] \hfill \\ 
		 		A Weboldalon történő kiíratást segítő objektum \newline
		 		Jelenleg sehol nem használjuk már, de a megvalósítás során fontos szerepe volt a hibajavításban
		\end{description}
		\item[model/interpolation] \hfill \\
		Az oldal 3 fő részegységének függvényei
			\begin{description}
			\item[menulist.js : ] 
				Interpolációk lista megvalósítása \newline
				function interpolationMenulist (aConfig) Objektum fájlja
		  	\item[plot.js : ] \hfill \\ 
		  		Interpolációs grafikon megvalósítása \newline
				function interpolationPlot(aConfig) Objektum fájlja
			\item[table.js : ] \hfill \\
				Interpolációs táblázat megvalósítása \newline
				function interpolationTable(aConfig) Objektum fájlja
			\end{description}
	\end{description}
\subsection{Fontosabb objektumok és függvények}
	\hfill
	Az objektumokat legtöbb esetben egy függvény generálja, melyben \"that.\"-al jelöltek azok, melyeket a visszatérés után felhasználunk az eseménykezelésekhez.
	\begin{description}
		\item[makePolinome(inPolinome, plotFor)] \hfill \\ 
			Polinom pontjainak legenerálására szolgáló függvény, a grafikon kirajzolónak megfelelő típusban
			\begin{description}
				\item[inPolinome] polinom
				\item[plotFor] polinom intervalluma és pontossága
			\end{description}
		\item[Connection.request(aConfig)] \hfill \\ 
			Elküldi a szervernek az értékeket
			\begin{description}
				\item[aConfig.params] a kommunikációban a paraméter amelyet átküldünk a szervernek
				\item[aConfig.callback] sikeres visszatérés esetén lefutó függvény
			\end{description}
		\item[basicTable (aConfig)]
			\hfill \\ 
			Egy alap tábla objektum. Ennek segítségével lehet létrehozni az interpolációs táblázatot és a menü listát(interpoláció választó)
			\begin{description}
			\item[that.addNewCellToRow(rowIndex, textValue, inputAttributes)] 
				\hfill \\  Ad egy új cellát a sorhoz
			\item[that.addNewRowToTable(data)]
				\hfill \\ Ad egy új sort a táblázathoz
			\item[that.addNewColumnToTable(data)]
				\hfill \\ Ad egy új oszlopot a táblázathoz
			\item[that.newTable()] 
				\hfill \\ Új tábla létrehozása
			\item[that.setCellForm((i , j, attributes))] 
				\hfill \\ Egy adott cella megformázás beállítása
			\item[that.getNumOfCols()] 
			 	\hfill \\ Vissza adja az oszlopok számát
			\item[that.getNumOfRows()]
				\hfill \\ Vissza adja a sorok számát
			\item[that.getRow(i)]
				\hfill \\ Vissza adja a sort az index alapján. 
				Ha nincs olyan indexű akkor null
			\item[that.getInputTag(i, j)]
				\hfill \\ Vissza tér a tábla input elemével
			\item[that.getValue(i, j)]
				\hfill \\ Egy adott cella érték lekérdezése
			\item[that.findValue(column, value)] 
				\hfill \\ Megkeresi melyik sorban van egy adott értéket
			\item[that.setValue(i, j, value, form)]
				\hfill \\ Beállít egy adott értéket egy cellának
			\item[that.deleteTable()]
				\hfill \\ Teljesen törli a táblázatot
			\item[that.remove(row)]
				\hfill \\ Kivesz egy sort a táblázatból
			\item[addNewRowTagToTable ()]
				\hfill \\ Ad egy új sort a táblázathoz
			\item[addCellToRow(index)]
				\hfill \\ Ad  egy cellát a sorhoz
			\item[setAttributes(object, attributes)]
				\hfill \\ Beállítja egy objektum tulajdonságait
			\item[makeTextInput (value,  attributes)]
				\hfill \\  TextInput hozzáadása a sorhoz
			\end{description}
		\item[interpolationMenulist (aConfig)] 
			\hfill \\ 
			Az interpolációs menü függvénye. Itt tarjuk számon az aktuálisan betöltött adathalmazt.
			\begin{description}
			\item[that.newItem()] 
			\hfill \\ Új Lista elem
			\item[that.getDataArray(server)] 
			\hfill \\ Vissza adja az adathalmazt, tömb formában. Ebben a formában küldjük fel a szervernek.
			\item[that.getDataObject()] 
			\hfill \\ Vissza adja az adathalmazt, egy objektum formájában. Az Objektum értékeinek kulcsa, az interpolációk egyedi azonosítója (id-ja).
			\item[that.saveItemSettings()] 
			\hfill \\ Elmenti az adatokat az aktuálisan kijelölt sorba.
			\item[that.loadItemSettings(index)]
			\hfill \\ Feldogozza az adatsort a táblából, és betölti az adatokat a táblába.
			\item[that.loadAll(savedObject, resultObject)] 
			\hfill \\Betölti az összes Interpolációt az adott adathalmazból
			\item[newMenulist()] 
			\hfill \\
			Új menülista: régi menü kitörlése, és egy új generálása
			\hfill \\ 
			\end{description}
		\item[interpolationPlot (aConfig)]
			\hfill \\ Grafikon megjelenítése: "Flot" segítségével létrehoztam az alábbi Objektumot. Ebben valósítottam meg a kirajzolást, és annak tulajdonságait.
			\begin{description}
			\item[that.refresh(points, polynomials)]
			\hfill \\ Pontok és a polinomok alapján frissíti a grafikont
			\item[that.getPlotSettings]
			\hfill \\ Visszatér a grafikon megjelenítési tulajdonságokkal. Ennek segítségével mentünk.
			\item[that.setPlotSettings]
			\hfill \\ Betölti a grafikon megjelenítési tulajdonságokat.
			\item[generateData(senderData, polynomial)]
			\hfill \\ Legenerálja a grafikon azon bemenő paraméterét, amely a megjelenítendő adatokat állítja,

			\item[generateType()]
			\hfill \\ Legenerálja a grafikon azon bemenő paraméterét, amely a grafikon megjelenítését állítja
			\item[setDefaultSettings()]
			\hfill \\ Legenerálja a grafikon azon bemenő paraméterét, amely a grafikon megjelenítését állítja
			\item[generatePointSet(tableArray, derivNum)]
			\hfill \\ Legenerálja az adott pontokat, az interpolációs táblázatból
			\end{description}

		\item[interpolationTable (aConfig)]
			\hfill \\ 
				Az interpolációs Táblázat logikája, és generálása. Ebben a táblázatban tekinthetjük meg a pontokat.
			\begin{description}
			\item[that.addPoint(x, y, dn)] 
			\hfill \\ Hozzá adja a pontot a táblázathoz. Ha létezik ezen az X-en pont akkor frissíti.
			\item[that.setPoints(tableArray)] 
			\hfill \\ Feltölti a táblázatot egy adott tömb értékeivel
			\item[that.setData(data)] 
			\hfill \\ Feltölti az adatokkal a táblát
			\item[that.getData()] 
			\hfill \\ Vissza adja a táblázatban szereplő adatok
			\item[that.getPoints()] 
			\hfill \\ Vissza adja a táblázatban szereplő pontokat
			\end{description}
	\end{description}



%% ----------------------------------------------{Elosztott rendszer}
\section{Elosztott rendszer  megvalósítása}
Elosztott rendszer Erlang-ban lett megvalósítva. Az elosztást interpolációnként végezzük, vagyis annyi node-ot hozunk létre amennyi interpolációt kívánunk egyszerre kiszámítani. \newline
A szerver figyel egy portot hogy érkezett-e rá adat. Ha érkezett adat az adott portra, azt kibontja, és elvégzi a szükséges műveleteket. A JSON-t kibontja, és feldolgozza. Kinyer belőle egy listát mely az interpolálni kívánt pontokat és tulajdonságokat tartalmazza. \newline
Tudjuk pontosan hány eleme van a listának, és annyi processzt hozunk létre. Ha vannak felcsatlakozva node-ok akkor a processzt az adott node-on is meg tudja hívni.
Ha létrehozta a processzeket lista elemein végig megy, és azokat szétküldi a processzeknek, majd megvárja míg az összes végig ér, és vissza térve megkapja az eredményt.
\subsection{Web-szerver kommunikáció}
	A webszerver kommunikációhoz a fájlok a httpServer.erl fájlban találhatóak meg. Az ebben található függvényeket a main-ben hívjuk meg amikor inicializáljuk a szervert.
	\begin{description}
	\item[httpServer:start(Port, WatcherNode)] 
		\hfill \\
		Elindítja a szervert, az adott porton. \newline
		Ezt a függvényt a main-ben hívjuk, meg ahol már megkapja a node-figyelő pid-jét és az alapértelmezett port-ot 
	\item[httpServer:response(Str, WatcherNode)] \hfill \\ 
		Miután érkezik egy kérés a szervernek ebben a függvényben kezeljük le. Innen indul ki minden folyamat ami a számítást végzi. \newline 
		Az alábbi sorrendben hívódnak meg a függvények: \newline
		getDecodeData, convertData, callMain, convertToSend
	\item[httpServer:getDecodeData(\_)] \hfill \\ 
		Vissza tér a szervernek küldött paraméterrel
	\item[httpServer:convertData(ResponseParams)] \hfill \\ 
		Létrehozza a kapott adatból az Erlang struktúrát
	\item[httpServer:callMain(RespJson, WatcherNode)] \hfill \\ 
		Amikor az adatokat feldolgoztuk és minden rendben ment, elindítjuk a main függvényét, ezen függvény segítségével.
	\item[httpServer:convertToSend(Object)] \hfill \\ 
		Amikor a számítás véget ért, létrehozzunk a visszaküldéshez szükséges adatstruktúrát, majd elküldjük a szervernek.
	\end{description}
\subsection{Adat feldolgozás}
	Az adatot JSON-ben kapja a szerver. Az adathalmaz kibontásához MonchiJSON lett alkalmazva. 
	A segédfüggvények és konvertálók a "Utility/structHandler.erl" fájlban lettek megvalósítva.\newline
	Elsősorban a megkapott speciális adathalmaz kibontására használtak az itt lévő függvények, de egyéb segédfüggvények is megtalálhatóak ebben a fájlban, amelyek a konvertálással kapcsolatosak.

	\subsubsection{\underline{
		Mochi-json kibontásához használt segédfüggvények:
	}}
	\begin{description}
		\item[structHandler:getElementByKeyList(KeyList, DataSetElement)] \hfill \\ 
		Vissza tér egy értékkel, amely az adott kulcson van, ha egy elemű a kulcs lista. Több elem esetén a kulcsokban lévő értékeket nézi, és vissza adja a legbelső kulcson lévő elemet.

		\item[structHandler:getElementByKey()] \hfill \\ 
		Vissza tér egy objektumban az adott kulcson lévő értékkel
	\end{description}
	\subsubsection{\underline{Adat Struktúra az interpoláció meghívásához}}
	\begin{description}

		\item[structHandler:getDataByJson(JsonSting)] \hfill \\
		A mochi-json dekódoló meghívása, vissza tér egy Erlang struktúrával.
		
		\item[structHandler:getDataSet(Data)]\hfill \\ 
		Vissza tér az adatok halmazával. Ebből a halmazon, vagyis listán kell végig menni, és szétosztani az elemeit. 
		
		\item[structHandler:getPoints] \hfill \\
		Pontok vissza nyerése egy speciális módon, melyet a "calulator" fel tud használni

		\input{./../code1.tex}

		\item[structHandler:<Számítási paraméterek>] \hfill \\ 
		getInverse(DataSetElement) - inverz-e \newline
		getType(DataSetElement) mi a típusa? \newline
		getId(DataSetElement) egyedi azonosítója \newline
		getPoints(DataSetElement) pontok struktúrája
	\end{description}
	\subsubsection{\underline{Az eredmény vissza nyeréséhez az alábbi segédfüggvényeket kellett használni:}}
	\begin{description}
	
		\item[structHandler:convertToMochi(Object)] \hfill \\ 
		A mochi-json Erlang struktúra annyira nem egyértelmű elemekből áll. Speciálisan kell felépíteni az eredményt. Ez a függvény megkap egy Erlang listát és átkonvertálja mochi-json-nak megfelelő struktúrává, majd átkonvertálja egy json string-gé.

		\item[structHandler:simplifyPolinomial(Result, Array) ] \hfill \\ 
		Egyszerűsíti a polinomot amelyet eredményül kapott.
	
	\end{description}
\subsection{Gép-szerver kommunikáció}
	\begin{description}
	\item[pidWatch:startPidWatch()]
	\hfill \\ Elindítja a node-figyelőt, melyben feliratkozni lehet a listára, vagy lekérdezni az adatokat. A node-figyelő indulás után figyelni fog és ha küldenek neki egy kérést, akkor azt kezeli. 
	\item[pidWatch:registerToServer(Pong\_Node)]
	\hfill \\ Ezzel a kéréssel lehet felcsatlakozni a szerverre. A kérést elküldi és ha sikeres volt a feliratkozás, akkor ok-al tér vissza.
	\end{description}
\subsection{Elosztás megvalósítása}
	Az elosztást tartalmazó fájlokat a /DistributedSystem mappában találjuk meg. nodeHandler.erl fájlban találhatóak a processz létrehozással kapcsolatos függvények. fork.erl fájlban a processz kommunikáció logikája van megvalósítva.
	\begin{description}
		\item[nodeHandler:distributedFork(NumOfPids, DataList, WatcherNode)]
		\hfill \\
		Létrehozza a számításhoz szükséges Node Struktúrát.
		LogicModule-ban szereplő senderstart, recivestart, worker\_main 
		\item[nodeHandler:getNodelist]
		\hfill \\
		Lekéri a node-figyelőtől a felcsatlakozott node-okat.
		\item[nodeHandler:makeForkPids]
		\hfill \\
		Létrehozza a számításhoz szükséges új processzeket.

		\item[fork:senderArray]
		\hfill \\ 
			Végig megy egy adott tömbön és az elemeit szétküldi a processzeknek. 
		\item[fork:receiver]
		\hfill \\
			Válaszok érkezésére vár a processzektől. Ha minden válasz megérkezett, akkor vissza tér.
		\item[fork:worker\_main]
		\hfill \\
			A gyerek processzek függvénye. Várja a szülőtől az adatot, számol vele és vissza küldi.
		\item[fork:calculate]
		\hfill \\ 
			A fork-ból a számítást hívó függvény. Eredménnyel vissza tér, majd azt olyan formára hozza, amit vár a szülő. 
	\end{description}
%% ----------------------------------------------{Kalkulátor}
\section{Kalkulátor}
A Kalkulátor részben számítódik ki egy-egy interpolációnak az eredménye.
A megkapott adatok alapján számol, ha kell létre hozza a kezdő mátrixot, kiszámolja az eredmény mátrixot, majd annak segítségével kiszámolja a polinomot. \newline

\subsection{Felépítés}
	A számítást végző rész, nem áll sok fájlból, ezért ez nem lett sok részre szétbontva. 
	\begin{description}
		\item[calculator.cpp] 
		\hfill \\ Az egész számítás itt van megvalósítva, minden függvény, és segédfüggvény is.
		\item[erlang.cpp] 
		\hfill \\ Az Erlang-gal való kommunikáció megvalósítása
		\item[main.cpp] 
		\hfill \\ C++-os modul különálló tesztelésére kellett.
		\item[logTest.cpp] 
		\hfill \\ 
		Teszt függvények, melyekben dinamikus tesztesetek és paraméterezhető tesztesetek is vannak.
	\end{description}
\subsection{Fontosabb számítási függvények}
	\begin{description}
		\item[DArray interpolateMain] 
			\hfill \\ Kívülről meghívandó fő függvény mely elosztja és konvertálja a részeket
			\begin{description}
			  \item[DArray \&x :] Az x pontok listája 
			  \item[DMatrix \&Y :] Az x pontokhoz tartozó y pontok halmaza
			  \item[string type :] 
			  	Interpoláció típusa: Lagrange, Newton, Hermite
			  \item[bool inverse :] Inverz interpoláció kell-e
			\end{description}
		\item[void interpolateMatrix(DArray \&x, 	DMatrix \&M)] \hfill \\ 
			Interpolációs Táblázat kiszámítása
		\item[DArray l(int j, DArray X))] \hfill \\ 
			Lagrange polinom számítás segédfüggvénye
		\item[DArray getLagrangePolinomyal(DArray X, DArray Y)] \hfill \\ 
			Lagrange polinom számítás
		\item[DArray omega(int j, DArray X)] \hfill \\ 
			Newton polinom számítás segédfüggvénye
		\item[DArray polynomialAddition(DArray P, DArray Q)] \hfill \\ 
			polinom összeadás
		\item[DArray polynomialMultiply(DArray P, DArray Q)] \hfill \\ 
			polinom szorzás
		\item[DArray getPointsFromMatrix(DMatrix Y)] \hfill \\ 
			Pontokat(0. derivált) vissza adja a mátrixból
		\item[DMatrix getMatrixFromPoints(DArray Y)] \hfill \\ 
			Mátrixot ad vissza a pontokból
		\item[DArray getDiagFromMatrix (DMatrix \&M)] 
		\hfill \\
			Diagonális lekérése a mátrixból
		\item[void getInterpolationMatrix]
		\hfill \\  \textbf{(DArray X, DMatrix Y, DArray \&resX, DMatrix \&resM)}
		\hfill \\
			 X és Y ponthalmazból vissza adja a mátrixot 
	\end{description}
\subsection{Elosztott rendszerrel való kommunikáció}
	Az elosztott rendszerben hívódó számítást Erlang - erl\_nif"-el sikerült megoldanom. 
	Az ezzel kapcsolatos dolgokat az Calculator/erlang.cpp tartalmazza.
	\begin{description}
		\item[static ERL\_NIF\_TERM calculate\_nif] \hfill \\
		Ennek a függvénynek a segítségével valósul meg a kettő közötti kommunikáció
		\item[static int convertVector] \hfill \\
		Erlang lista C++ vektorrá konvertálása
		\item[static int convertMatrix] \hfill \\
		Erlang lista lista konvertálása C++ vektor vektorrá
		\item[static ERL\_NIF\_TERM convertList] \hfill \\
		Erlang listává konvertálás egy C++ vektorból
		\item[convertTheType] \hfill \\
			típus számot konvertálja string-gé: 
			"newton", "hermite", "lagrange"
		\item[static ErlNifFunc nif\_funcs] \hfill \\
			Felsorolja milyen függvényeket importálunk az Erlang-ba
	\end{description}
	Calculator/calculator.erl fájl tartalmazza az alábbi függvényeket: 
	\begin{description}
		\item[calculator:init()] \hfill \\
			"erlang:load\_nif" segítségével betölti a lefordított c++ fájlt.
		\item[calculator:calculate(\_X, \_Y, \_Type, \_Inverz)] \hfill \\
			Erre a függvényre lesz ráfordítva a C++-os függvény.
		\item[calculator:calculateByData(DataSetElement)] \hfill \\
		A bejövő paraméterből kinyeri a pontokat és a típust, majd meghívja a számító függvényt.
	\end{description}


\section{Tesztelési terv}
	A felület manuális teszteléssel lett kipróbálva, automatizált tesztesetek nem lesznek.
\subsection{Kalkulátor tesztelés}
	Ebben a részben a cpp-ben írt tesztesetekről lesz szó. \newline
	A tesztelést folyamatosan végeztem a minta adatok alapján. A függvények implementálása közben ezekre a minta adatokra meghívtam, majd ezekkel számoltam. A teszteléshez a logTest.cpp fájlban található függvényeket alkalmaztam. \newline
	A fájlban a javítást segítő kiirató függvények, integrációs teszt esetek, valamint manuális, felület nélküli számítást végző tesztesetek vannak. \newline
	Ezeket a teszteket nagyrészt kiváltották a szerveren futó tesztek, így fejlesztésük abba maradt, előfordulhat hogy a tesztek elavultak.
	\begin{description}
		\item[bool testAll()] \hfill \\ 
			Minden teszt lefuttatása, ha nincs hiba futnak
		\item[void testInterpolation(bool logPoly = false)] \hfill \\ 
			Interpoláció tesztek lefuttatása
		\item[bool testMainInterpolation(bool logPoly = false)] \hfill \\ 
			Fő függvény tesztje
		\item[bool testNewton(bool logPoly = false)] \hfill \\ 
			Newton számítás tesztje
		\item[bool testLagrange(bool logPoly = false)] \hfill \\ 
			Lagrange Interpoláció tesztje
		\item[void testPolynomial()] \hfill \\ 
			Interpolációs Mátrix tesztje
		\item[void testMatrixInterpolation()] \hfill \\ 
			Manuális Interpolációs teszt
		\item[void testManualInterpolation()] \hfill \\ 
			Manuális Interpolációs teszt

		\item[testManualPolynomial()] \hfill \\ 
			Manuális Polinom tesztelő 
		\item[void genXSquaredPoints(DArray \&X, DMatrix \&Y)] \hfill \\ 
			generál egy minta X,Y ponthalmazt az $x^{2}$ 
			pontjaiból
		testMatrixInterpolation Segédfüggvénye
		feltölti az $x^{2}$ pontjaival 
	\end{description}
\subsection{Komponens és integrációs tesztelés}
	Főként az elosztást és a párhuzamosítást, valamint a szerveren lévő adatfeldolgozást teszteltem ilyen formában. Ezekkel a tesztesetekkel ellenőriztem a szerver és a számítás helyességét, és a szerver futást, miközben fejlesztettem.\newline
	Ezeket a teszteket érdemes lefuttatni, amikor a szervert konfiguráljuk. A szerveren lévő komponensek és azok egymással való kommunikációja fut le ilyenkor. Ha a teszten átmennek, akkor nagy vaolószínüséggel a szerveren már nem lehet probléma.\newline
	Viszont ha egy modul rosszul van leforgatva, vagy nincs betöltve, a tesztek hibát jeleznek. Ha a szerveren vagy gépen nem sikerült a tesztek lefutása, nem lehetséges a számítás elvégzése. Ennek oka valamelyik modul rosszul való betöltése, vagy az Erlang, GCC verziója nem megfelelő a számításokhoz.\newline
	Az átfogó tesztelés a ServerConfig/test.erl fájlban található. 
		\begin{description}
		\item[test:fork] \hfill \\
			Teszt futtatása a fork-nak ez a teszteset az párhuzamosítás miatt volt fontos. Viszont egy másik teszt átvette  ahelyét. 
			\newline
			Ha mégis szükség lenne az általános párhuzamosítás tesztelésére, ezt kellene továbbfejleszteni.

		\item[test:runCheck, run] \hfill \\
			Futtatást kezelő függvények
			Lefuttatják azokat a teszteket amiket a ServerConfig/main.erl-ből már el lehet indítani. 
			A main-ben található függvény tesztelésére a  test:simulateDistributedCalculate függvényt használjuk, amit a bin/run.erl-ben lévő tesztesetek 
		\item[test:simulateDistributedCalculate] \hfill \\
			Egy olyan minta adatból, melyet a szerver is küldhet, elvégzi a számítást és ellenőrzi az eredményt. \newline
			Ha megadjuk neki a node-figyelő pid-jét akkor elosztott számítást is teszteli, és a node-figyelővel való kommunikációt. 
		\item[test:simplifyPolinomialTest] \hfill \\
			Ellenőrzi a struktúra kezelőben megvalósított polinom egyszerűsítést.  
		\item[test:convertMochiElements] \hfill \\
			structHandler: getTableData és getElementByKey tesztelésére írt függvény.
		\item[test:getResultTest] \hfill \\
			Eredmény konvertálásának tesztje. Szimulál egy processzektől vissza kapható eredményt, majd ezt átalakítja a küldéshez megfelelő formátummá.
		\item[test:getParseJSONParams] \hfill \\
			Json string-ből a számításhoz szükséges minden paraméter kinyerésének tesztelése (structHandler teszt).
		\item[test:convertStruct] \hfill \\
			structHandler függvényeinek tesztje: 
			getNewPointStruct, appendNewPointStruct, convertPoints
		\item[test:simulateFirstParseAndRun] \hfill \\
			Kibontja az első elemet a mintából, és számítás után ellenőrzi az eredmény helyességét. \newline
			Ez a teszt a számítást és az adat konvertálást teszteli, a párhuzamosítást/elosztást nem.
		\item[test:getFirstElementOfDataSet] \hfill \\
			Vissza adja a minta adatok első elemét.
		\item[test:getJSONString] \hfill \\
			Egy minta adathalmazt ad vissza (json string) ami jöhet a felületről.
		\item[test:getResultTestHelper] \hfill \\
			Számítási eredményekből és az elvárt eredményből a tesztelés eredményt állítja elő. 
	\end{description}

\subsection{Manuális tesztelés}
	Elsősorban a felület átfogó tesztelését végeztem ilyen módon, de a szerverrel való kommunikációnál és az elosztásnál is előkerültek ilyen módon hibák. \newline
	Az alábbi táblázatban felsoroltam a hibákat, melyek feltűntek a tesztelés során. 
	\begin{center}
  	\begin{tabular}{| p{4cm} | p{1.5cm} | p{8cm} |}
    \hline
    Hiba & Javítva & Info
    \\ \hline
    	Szerver hiba bizonyos mennyiségű adatküldése felett 
      &
    	nem
      &  
    	Előidézés: 9-nél több egyszerű adat felküldése, minta nagy adatból 4db felett.
    	A szerver egybe küldi az értékeket de, valamiért a httpServer modul már nem kapja meg a végét. Nem küldi 2 részletben, ezt kizártuk.
    \\ \hline
    	Hermite inverz nincs implementálva, és mégis beállítható a felületen.  
      &
      	nem
      &
		El tudjuk küldeni az oldalról úgy az adatokat hogy Hermite interpolációnál is állítható az inverz, közben a szerver nem inverz interpolációt fog számolni.
    \\ \hline
        Ha kilép egy node, akkor elszáll a számítás 
      &
      	nem
      &
		Ötletek: node-ok kivételére is kellene opció,vagy kezelni kellene az elszálló node-okat.
    \\ \hline
        Node Lista lekérdezésnél valamikor végtelen ciklusba fut a lekérdezés. 
      &
      	nem
      &
		Hiba: túl sokszor küldjük el ugyanazt az üzenetet, és kapunk vissza rossz választ, kéne bele egy időkorlát is, a várakozásra. 
	\\ \hline
        Nem jó pontosság esetén nem jelenik meg a polinom
      &
      	igen
      &
		Előidézés: beírsz betüket a pontossághoz 
    \\ \hline
        Egy interpoláció adatbetöltési hibák
      &
      	nem
      &
      	Egy interpoláció tulajdonságainak betöltésénél nem állítja be az interpoláció típust és azt hogy inverz-e.
      	Nem jelenítjük meg a polinomokat sem bármilyen egyéb formában.
    \\ \hline
        Eredmény betöltésnél előfordul hogy a pontosság undefined 
      &
      	nem
      &
		Előidézés: ? Minta adatban fordul csak elő, de ha onnan  is betöltődhet akkor máshonnan is, amikor betölti az adatokat le kellene ezt kezelni.
    \\ \hline
  	\end{tabular}
	\end{center}